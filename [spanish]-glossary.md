<!-- TITLE: [Spanish] Glossary -->



# Criptografía 
Ver también: [http://en.wikipedia.org/wiki/Public-key_cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)

* **Computational infeasibility**: un proceso es inviable desde el punto de vista computacional, si tomaría un tiempo impracticablemente largo (por ejemplo, miles de millones de años) en hacerlo para cualquier persona que pudiera tener un interés en llevarlo a cabo. Generalmente, 2<sup>80</sup> pasos computacionales se consideran el límite inferior para la inviabilidad computacional.
* **Hash**: una función hash (o algoritmo hash) es un proceso, por el cual una pieza de datos de tamaño arbitrario (podría ser cualquier cosa, una pieza de texto, una imagen o incluso una lista de otros hashes) se procesa en una pequeña porción de datos (normalmente 32 bytes) que se ve completamente al azar, y de la cual no se pueden recuperar datos significativos sobre el documento, pero que tiene la importante propiedad, de que el resultado de hash de un documento en particular es siempre el mismo. Además, es muy importante que no sea computacionalmente factible encontrar dos documentos que tengan el mismo hash. Generalmente, cambiar incluso una letra en un documento cambiará completamente el hash; por ejemplo, el hash SHA3 de "Saturday" es `c38bbc8e93c09f6ed3fe39b5135da91ad1a99d397ef16948606cdcbd14929f9d`, mientras que el hash SHA3 de Caturday es `b4013c0eed56d5a0b448b02ec1d10dd18c1b3832068fbbdc65b98fa9b14b6dbf`. Los valores hash generalmente se usan como una forma de crear un identificador acordado globalmente para un documento particular que no se puede falsificar.
* **Encryption (_Cifrado/Codificación/Encriptación_)**: La encriptación es un proceso mediante el cual un documento (**texto plano**) se combina con una cadena de datos más corta, llamada clave(**"_key_"**) (por ejemplo `c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4`) para producir una salida (texto cifrado/**_ciphertext_**) que puede ser "descifrado" en el texto original por alguien más que tenga la clave, pero que es incomprensible y no es computacionalmente descifrable para cualquiera que no tenga la clave.
* **Cifrado de clave pública** / (**_Public key encryption_**): Un tipo especial de encriptación, en el que hay un proceso para generar dos claves al mismo tiempo (generalmente, una **clave pública**/**public key** y una **clave privada**/**private key**), de forma que los documentos cifrados usando una clave se puedan descifrar con la otra. Generalmente, como el mismo nombre dice, se publica la clave pública y se guarda la clave privada.
* **Digital signature** / **Firma digital**: Un algoritmo de firma digital es un proceso mediante el cual el usuario puede producir una cadena corta de datos llamada "firma" de un documento utilizando una clave privada de manera que cualquier persona con la clave pública correspondiente, la firma y el documento pueda verificar que (1) el documento fué "firmado" por el propietario de esa clave privada en particular, y (2) el documento no se modificó después de que se firmara, Tenga en cuenta que esto difiere de las firmas tradicionales donde puede _garabatear_ texto adicional en un documento después de firmarlo y no hay forma de notar la diferencia; cualquier cambio en el documento invalidará la firma.

# Blockchains
Ver también: [https://bitcoin.org/en/vocabulary](https://bitcoin.org/en/vocabulary)
* **Address** / **(Dirección)**: Una dirección es esencialmente la representación de una clave pública que pertenece a un usuario en particular; por ejemplo, la dirección asociada con la clave privada dada anteriormente es `0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826`. Tenga en cuenta que, en la práctica, la dirección es técnicamente el hash de una clave pública, pero, para simplificar, es mejor ignorar esta distinción.
* **Transaction** / **(Transacción)**: Una transacción es un mensaje firmado digitalmente que autoriza alguna acción en particular asociada con la cadena de bloques. En una moneda, el tipo de transacción dominante es el envío de unidades de moneda o tokens a otra persona; en otros sistemas, las acciones como registrar nombres de dominio, realizar y cumplir ofertas comerciales y celebrar contratos, también son tipos de transacciones válidos.
* **Block** / **(Bloque)**: Un bloque, es un paquete de datos, que contiene cero o más transacciones, el hash del bloque anterior ("principal") y, opcionalmente, otros datos. Debido a que cada bloque (excepto el "bloque génesis" inicial / _"genesis block"_) apunta al anterior, la estructura de datos que forman se llama "blockchain (cadena de bloques)".
* **State** / **(Estado/situación)**: El conjunto de datos que una red blockchain necesita controlar estrictamente, y que representa datos actualmente relevantes para las aplicaciones de la cadena. En una moneda, esto es simplemente, saldos; en aplicaciones más complejas, esto podría referirse a otras estructuras de datos que la aplicación necesita para realizar un seguimiento (por ejemplo, quién tiene qué nombre de dominio, cuál es el estado de un contrato determinado, etc.). El estado posterior (**post-state**) de un bloque es el estado después de ejecutar todas las transacciones en los antecesores del bloque comenzando desde el origen hasta (e incluyendo) las transacciones en ese bloque.
* **History** / **(Historia)**: Transacciones y bloques pasados. Tenga en cuenta que el estado es una funcion determinista de la historia.
* **Account** / **(Cuenta)**: Una cuenta es un objeto en el estado; en un sistema monetario, es un registro de cuánto dinero tiene un usuario en particular; en sistemas mas complejos, las cuentas pueden tener diferentes funciones.
* **Proof of work** / **(Prueba de trabajo)**: Una propiedad importante de un bloque en Ethereum, Bitcoin y muchas otras criptomonedas debe ser menor que algún valor objetivo. La razón por la cual esto es necesario, es que, en un sistema descentralizado, cualquiera puede producir bloques, por tanto, para evitar que la red se llene de bloques, y para proporcionar una forma de medir cuánto consenso hay detrás de una versión particular de la cadena de bloques, de alguna manera debe ser difícil producir un bloque. Debido a que los hashes son pseudoaleatorios, encontrar un  bloque cuyo hash es menor que `0000000100000000000000000000000000000000000000000000000000000000` requiere un promedio de 4.3 mil millones de intentos. En todos estos sistemas, el valor objetivo se autoajusta  de modo que, en promedio, un nodo en la red, encuentra un bloque cada N minutos (por ejemplo, N=10 en Bitcoin y 1 para Ethereum).
* **Proof of work nonce** / **(Prueba de trabajo nonce)**: Un valor irrelevante en un bloque que puede ajustarse para tratar de satisfacer la condición de la prueba de trabajo.
* **Mining** / **(Minería)**: La minería, es el proceso de agregar repetidamente transacciones, construir un bloque y probar nonces diferentes hasta que se encuentre un nonce que satisfaga la condición de la prueba de trabajo. Si un minero tiene suerte y produce un bloque válido, se le premia con un cierto número de monedas como recompensa, así como todas las tarifas de transacción en el bloque, y todos los mineros comienzan a tratar de crear un nuevo bloque que contenga el hash del nuevo bloque generado como el anterior.
* **Stale** / **(Pasado/Viejo)**: Un _pasado_ es un bloque que se crea cuando ya hay otro bloque con el mismo padre anterior; por lo general, se descartan y son un esfuerzo desperdiciado.
* **Fork** / **(Bifurcación)**: Una situación en la que se generan dos bloques que apuntan al mismo bloque que su padre, y una parte de los mineros ve un bloque primero y algunos el otro. Esto puede conducir a que dos bloques crezcan al mismo tiempo. En general, es matemáticamente _casi cierto_ que una bifurcación se resolverá en cuatro bloques, ya que los mineros de una cadena tendrán suerte y la cadena crecerá y todos los mineros se cambiarán a ella. Sin embargo, las bifurcaciones pueden durar más, si los mineros no están de acuerdo sobre si un bloque en particular es válido o no.
* **Double spend** / **(Doble gasto)**: Una bifurcación deliberada, donde un usuario con gran cantidad de potencia minera envía una transacción para comprar algún producto, luego de recibir el producto crea otra transacción enviándose las mismas monedas a sí mismo. El atacante luego crea un bloque, en el mismo nivel que el bloque que contiene la transacción original, pero que contiene la segunda transacción y comienza a minar en la bifurcación. Si el atacante si el atacante tiene más del 50% de toda la potencia minera, se garantiza que el _doble gasto_  tendrá éxito eventualmente a cualquier profundidad de bloque. Por debajo del 50%, hay alguna probabilidad de éxito, pero por lo general, sólo es sustancial a una profundidad de hasta 2-5; por este motivo, la mayoría de los intercambios de criptomonedas, los sitios de juegos, de apuestas y los servicios financieros esperan hasta que se hayan producido seis bloques ("seis confirmaciones") antes de aceptar un pago.
* **Light client** / **(Cliente ligero)**: Un cliente que descarga sólo una pequeña parte de la cadena de bloques, permitiendo a los usuarios de hardware de bajo consumo o bajo almacenamiento (como teléfonos inteligentes y computadoras portátiles) mantener, casi, la misma garantía de seguridad al descargar selectivamente partes pequeñas del estado sin necesidad de gastar megabytes de ancho de banda y gigabytes de almacenamiento en validación y el mantenimiento de la blockchain al completo.

# Ethereum Blockchain
Ver también: [http://ethereum.org/ethereum.html](https://www.ethereum.org/)

* **Serialization** / **(Publicación por entregas/Serialización)**: El proceso de convertir una estructura de datos en una secuencia de bytes. Ethereum usa internamente un formato de codificación de prefijos de longitud recursiva (_Recursive-length prefix encoding_-"RLP"), expuesto [aquí](http://wikijs.ethereum.wiki/RLP)
* **Patricia tree** (or **trie**) / **(Arbol de Patricia)**: Una estructura de datos que almacena el estado de cada cuenta. El _"trie"_ se construye comenzando desde cada nodo individual, luego dividiendo los nodos en grupos de hasta 16 y _juntando/aglutinando_ cada grupo, luego haciendo hashes de hashes y demás hasta que haya un "_hash raiz(root hash)_" para todo el _trie_. El _trie_ tiene las propiedades importantes, de que (1) hay exactamente un _trie_ posible y, por lo tanto, un posible hash de raíz para cada conjunto de datos, (2) es muy fácil actualizar, agregar o eliminar nodos en el _trie_ y generar la nueva raíz hash, (3) no hay forma de modificar ninguna parte del árbol sin cambiar el hash raíz, por lo que si el hash raíz está incluido en un documento firmado o en un bloque válido, la firma o prueba de trabajo asegura todo el árbol, y (4) uno puede proporcionar solo la "rama" de un árbol que desciende a un nodo particular como prueba criptográfica, de que ese nodo está realmente en el árbol con ese contenido exacto. Los árboles de Patricia también se usan para guardar el almacenamiento interno de cuentas, así como las transacciones y los _"ommers"_.
Mirar [aquí](https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/) para una descripción mas detallada.
* **Uncle** / **(tío)**: Mirar **_Ommer_**, la alternativa neutral de género al tio/tia.
* **Ommer**: Un hijo de un padre, padre de un bloque que no es el padre, o más generalmente un hijo de un antepasado que no es en sí mismo un antepasado. Si A es un ommer de B, B es un **_nibling_** (sobrina/sobrino) de A.
* **Uncle inclusion mechanism** / **(Mecanismo de inclusión del tío)**: Ethereum tiene un mecanismo donde un bloque puede incluir a sus tíos; esto asegura que los mineros que crean bloques que no se incluyen en la dacena principal, puedan obtener recompensas.
* **Account nonce** / **(Nonce de cuenta)**: Un contador de transacciones en cada cuenta. Esto evita ataques de repetición cuando una transacción envía, por ejemplo, 20 monedas de A a B, puede ser reproducida por B una y otra vez para drenar continuamente el equilibrio de A.
* **EVM code** / **(Código de EVM)**: Código de la máquina virtual de Ethereum, el lenguaje de programación en el que las cuentas en la cadena de bloques de Ethereum, pueden contener código. El código EVM asociado con una cuenta, se ejecuta cada vez que se envía un mensaje a esa cuenta, y tiene la capacidad de leer/escribir en el almacenamiento, y enviar mensajes por sí mismo.
* **Message** / **(Mensaje)**: Algo como una "transacción virtual" enviada por código EVM de una cuenta a otra. Tenga en cuenta que las "transacciones" y los "mensajes" en Ethereum son diferentes. Una "transacción" en el lenguaje de Ethereum se refiere específicamente a una pieza de datos firmada digitalmente, que se origina, en una fuente distinta a la ejecución del código EVM, para ser registrada en la cadena de bloques. Cada transacción activa un mensaje asociado, pero los mensajes también pueden enviarse por código EVM, en cuyo caso, nunca se representan en ningún lugar.
* **Storage** / **(Almacenamiento)**: Una base de datos clave/valor contenida en cada cuenta, donde las claves y los valores son cadenas de 32-bytes, pero pueden contener cualquier cosa.
* **Externally owned account** / **(Cuenta externa)**: Una cuenta controlada por una clave privada. Las cuentas de propiedad externa, no contienen código EVM.
* **Contract** / **(Contrato)**: Una cuenta que contiene y está controlada por el código EVM. Un contrato no tiene propietario una vez se haya liberado.
* **Ether**: El token criptográfico interno principal de la red de Ethereum. El Ether se usa para pagar las tarifas de transacción y computación de las transacciones de Ethereum.
* **Gas**: Una medida, más o menos equivalente a los pasos computacionales. Se requiere que cada transacción incluya un límite de gas y una tarifa que esté dispuesto a pagar por gas; los mineros tienen la opción, de incluir la transacción y cobrar la tarifa o no. Si el número total de gas utilizado por el cálculo generado por la transacción, incluido el mensaje original, y cualquier sub-mensaje que pueda activarse, es menor o igual al límite de gas, entonces la transacción se procesa. Si el total de gas excede el límite de gas, todos los cambios se revierten, excepto que la transacción aún es válida, y el minero incluso puede cobrar la tarifa. Cada operación tiene un gasto de gas; para la mayoría de las operaciones es ~3-10, aunque, algunas operaciones costosas, tienen gastos de hasta 700 y una transacción en sí tiene un gasto de 21000.

# Casper y la investigación de escalar:
Ver también: [https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ ](http://wikijs.ethereum.wiki/Proof-of-Stake-FAQ) y [https://github.com/ethereum/wiki/wiki/Sharding-FAQ](https://github.com/ethereum/wiki/wiki/Sharding-FAQ)

* **Security deposit** / **(Depósito de garantía)**: Una cantidad de Ether que un usuario deposita en un mecanismo (a menudo, un mecanismo de Prueba de Participación o _"Proof of Stake"_, aunque también puede usarse para otras aplicaciones) que un usuario normalmente espera poder retirar y recuperar, pero que puede perderlo en caso de mal comportamiento por parte del usuario.
* **Validator** / **(Validador)**: Un participante en el consenso de _"Prueba de Participación (PoS)"_. Los validadores deben enviar un depósito de seguridad para ser incluidos en el conjunto de validadores.
* **Economic finality** / **(Finalidad económica)**: Un bloque o estado, se puede considerar finalizado si se puede demostrar, que si se finaliza también un bloque o estado incompatible (por ejemplo, dos bloques diferentes en la misma altura), entonces existe evidencia que puede utilizarse para penalizar (los depósitos de seguridad de) las partes en falta por una cantidad de $X. Este valor X se denomina **cryptoeconomic security margin** _"(margen de seguridad criptoeconómica)"_ del mecanismo de finalidad.
* **Slashing condition** / **(Estado de corte)**: Una condición que, si se activa por un validador, hace que se destruya el deposito del validador.
* **Prepare** and **commit** / **(Prepararse** y **Asignar)**: Dos tipos de mensajes que los validadores pueden enviar en muchos tipos de protocolos de consenso; mirar también [https://medium.com/@VitalikButerin/minimal-slashing-conditions-20f0b500fc6c](https://medium.com/@VitalikButerin/minimal-slashing-conditions-20f0b500fc6c).
* **Fault** / **(Error)**: Una acción tomada por un validador (o más en general, un participante en un mecanismo) que no habría tomado si hubiese seguido correctamente el protocolo.
* **Liveness fault** / **(Falta de vivacidad)**: Un validador que no envía un mensaje que según el protocolo debería haber enviado (o que envía un mensaje mas tarde de lo que debería).
* **Censorship fault** / **(Error de censura)**: Un validador que no acepta mensajes válidos de otros validadores.
* **Equivocation** / **(Equivocación/Confusión)**: Un validador que envía dos mensajes que se contradicen entre sí, o más exactamente, un validador que envía dos mensajes, que un validador que ejecuta el algortimo correcto, solo podría enviar si envía un mensaje, "rebobina" su estado interno en algún momento antes de enviar ese mensaje. Un ejemplo simple, es, un remitente de transacción, que envía dos transacciones con el mismo nonce.
* **Invalidity fault** / **(Error de invalidez)**: Un validador que envía un mensaje que una computadora que ejecuta el algoritmo correcto no podría enviar, a menos que, manipule su estado interno de alguna otra manera que no sea el rebobinado.
* **Uniquely attributable fault** / **(Fallo único atribuible)**: Un fallo tal, que exista la evidencia clara de que pueda usarse para determinar exactamente, qué validador cometió el fallo. Por ejemplo, la _"falta de vivacidad"_ no son atribuibles de forma exclusiva, por que, si un mensaje de A, falla en llegar a B, podría ser porque A no envió ese mensaje, o porque B, no lo escuchó, mientras que el _"fallo de equivocación"_, son atribuibles de manera exclusiva.
* **Fraud proof** / **(Comprobante/prueba de fraude)**: Un conjunto de datos, normalmente una parte de un bloque más algunos "datos presenciales" adicionales (por ejemplo, ramas de Merkle), que se pueden usar para demostrar que un bloque determinado no es válido.
* **Data availability problem** and **Fisherman's dilemma** / **Problema de disponibilidad de datos** y **dilema del _pescador_**: Mirar [https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding](https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding).
* **Validity** / **(Validez)**: La propiedad de un estado que es de hecho, el resultado de ejecutar un historial válido de transacciones.
* **Data availability** / **(Disponibilidad de datos)**: La propiedad de un estado, de que, cualquier nodo conectado a la red puede descargar cualquier parte específica del estado que desee.
* **Tight coupling** / **(Vínculo estrecho)**: Las cadenas A y B están estrechamente acopladas si (i) cualquier estado de A apunta a un estado de B (y viceversa), y (ii) un estado de A no debe ser considerado admisible a menos que tanto el estado en sí mismo, como el estado de B que apunta, son válidos y están disponibles para datos.
* **Loose coupling** / **(Vínculo débil)**: Las cadenas A y B, están ligeramente acopladas si (i) cualquier estado de A apunta a algún estado de B (y viceversa), y (ii) no están estrechamente acoplados.
* **Shard** / **(Fragmento)**: Un subconjunto del estado que es administrado por diferentes nodos desde los nodos que administran otros fragmentos. Por lo general, los fragmentos, deben estar estrechamente acoplados, y las **_cadenas-laterales_** _(sidechains)_ deben estar ligeramente acopladas.

# No-blockchain

* **Whisper** / **(Susurro)**: Un protocolo próximo de mensajería P2P.
* **Swarm** / **(Enjambre/multitud)**: Un protocolo próximo de almacenamiento de datos P2P optimizado para alojamiento web estático.
* **Solidity**, **LLL**, **Serpent** y **Vyper**: Lenguajes de programación para escribir código de contrato que se puede compilar en código EVM. _"Serpent"_ también se puede compilar en LLL. _"Solidity"_ es un lenguaje similar a C++ (es el más utilizado), _"Serpent y Vyper"_, son lenguajes similares a Python (el desarrolladorde los dos, actualmente recomienda mejor Vyper), y LLL es un acrónimo de lenguaje similar a Lisp.
* **PoC**: Proof-of-concept (_"prueba de concepto"_), otro nombre para versiones previas al lanzamiento.